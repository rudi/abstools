
// https://github.com/antlr/stringtemplate4/blob/master/doc/cheatsheet.md
// https://github.com/antlr/stringtemplate4/blob/master/doc/groups.md

// * Helpers

annotations(node) ::= "<node.annotations:{a | <(a.templateName)(a)> }>"

// Annotation list followed by a newline
annotationsNL(node) ::= <<
<if (node.annotation)><annotations(node)>
<endif>
>>

// * Pure Expressions

IntLiteral(node) ::= "<node.content>"
FloatLiteral(node) ::= "<node.content>"
StringLiteral(node) ::= "\"<node.maudeEscapedString>\""
ListLiteral(node) ::= "[<node.pureExps:{e | <(e.templateName)(e)>}; separator=\", \">]"

NullExp(node) ::= "null"
ThisExp(node) ::= "this"

Annotation(node) ::= "[<(node.value.templateName)(node.value)>]"
TypedAnnotation(node) ::= "[<(node.access.templateName)(node.access)>: <(node.value.templateName)(node.value)>]"

VarUse(node) ::= "<node.name>"
FieldUse(node) ::= "this.<node.name>"
DataTypeUse(node) ::= "<annotations(node)><node.name>"
InterfaceTypeUse(node) ::= "<annotations(node)><node.name>"
ParametricDataTypeUse(node) ::= "<annotations(node)><node.name><if (node.param)>\<<node.params:{p | <(p.templateName)(p)>};separator=\", \">><endif>"
TypeParameterUse(node) ::= "<annotations(node)><node.name>"
ParamDecl(node) ::= "<annotations(node)><(node.access.templateName)(node.access)> <node.name>"
VarDecl(node) ::= "<(node.access.templateName)(node.access)> <node.name><if (node.initExp)> = <(node.initExp.templateName)(node.initExp)><endif>"

MinusExp(node) ::= "- <(node.operand.templateName)(node.operand)>"
NegExp(node) ::= "! <(node.operand.templateName)(node.operand)>"

EqExp(node) ::= "(<(node.left.templateName)(node.left)> == <(node.right.templateName)(node.right)>)"
NotEqExp(node) ::= "(<(node.left.templateName)(node.left)> != <(node.right.templateName)(node.right)>)"
AndBoolExp(node) ::= "(<(node.left.templateName)(node.left)> && <(node.right.templateName)(node.right)>)"
OrBoolExp(node) ::= "(<(node.left.templateName)(node.left)> || <(node.right.templateName)(node.right)>)"
LTExp(node) ::= "(<(node.left.templateName)(node.left)> \< <(node.right.templateName)(node.right)>)"
GTExp(node) ::= "(<(node.left.templateName)(node.left)> > <(node.right.templateName)(node.right)>)"
LTEQExp(node) ::= "(<(node.left.templateName)(node.left)> \<= <(node.right.templateName)(node.right)>)"
GTEQExp(node) ::= "(<(node.left.templateName)(node.left)> >= <(node.right.templateName)(node.right)>)"
AddAddExp(node) ::= "(<(node.left.templateName)(node.left)> + <(node.right.templateName)(node.right)>)"
SubAddExp(node) ::= "(<(node.left.templateName)(node.left)> - <(node.right.templateName)(node.right)>)"
MultMultExp(node) ::= "(<(node.left.templateName)(node.left)> * <(node.right.templateName)(node.right)>)"
DivMultExp(node) ::= "(<(node.left.templateName)(node.left)> / <(node.right.templateName)(node.right)>)"
ModMultExp(node) ::= "(<(node.left.templateName)(node.left)> % <(node.right.templateName)(node.right)>)"

DataConstructorExp(node) ::= <<
<node.constructor><if(node.param)>(<node.params:{a | <(a.templateName)(a)>}; separator=", ">)<endif>
>>

FnApp(node) ::= <<
<node.name><if (!node.variadicFnApp)>(<endif><\\>
<node.paramList:{p | <(p.templateName)(p)>}; separator=", "><\\>
<if (!node.variadicFnApp)>)<endif>
>>

// Unused except if -keepsugar is true
ParFnApp(node) ::= <<
<node.name><\\>
(<node.funcParamList:{p | <(p.templateName)(p)>}; separator=", ">)<\\>
(<node.paramList:{p | <(p.templateName)(p)>}; separator=", ">)
>>

LetExp(node) ::= <<
let (<(node.var.templateName)(node.var)>) <\\>
= <(node.val.templateName)(node.val)> <\\>
in <(node.exp.templateName)(node.exp)>
>>

IfExp(node) ::= <<
if <(node.condExp.templateName)(node.condExp)> <\\>
then <(node.thenExp.templateName)(node.thenExp)> <\\>
else <(node.elseExp.templateName)(node.elseExp)>
>>

CaseExp(node) ::= <<
case <(node.expr.templateName)(node.expr)> {
    <node.branchs:{b | <(b.left.templateName)(b.left)> => <(b.right.templateName)(b.right)>;
}>}
>>

UnderscorePattern(node) ::= "_"
PatternVar(node) ::= "<(node.var.templateName)(node.var)>"
PatternVarUse(node) ::= "<node.name>"
PatternVarDecl(node) ::= "<node.name>"
LiteralPattern(node) ::= "<(node.literal.templateName)(node.literal)>"
ConstructorPattern(node) ::= <<
<node.constructor><if(node.param)>(<node.params:{a | <(a.templateName)(a)>}; separator=", ">)<endif>
>>

// * Side-effect Expressions

GetExp(node) ::= "<(node.pureExp.templateName)(node.pureExp)>.get"

NewExp(node) ::= "new <if (node.local)>local <endif><node.className>(<node.params:{p | <(p.templateName)(p)>};separator=\", \">)"

SyncCall(node) ::= <<
<(node.callee.templateName)(node.callee)>.<node.method>(<node.params:{p | <(p.templateName)(p)>};separator=", ">)
>>

AsyncCall(node) ::= <<
<(node.callee.templateName)(node.callee)>!<node.method>(<node.params:{p | <(p.templateName)(p)>};separator=", ">)
>>

AwaitAsyncCall(node) ::= <<
await <(node.callee.templateName)(node.callee)>!<node.method>(<node.params:{p | <(p.templateName)(p)>};separator=", ">)
>>

OriginalCall(node) ::= <<
original(<node.params:{p | <(p.templateName)(p)>};separator=", ">)
>>

// * Statements

SkipStmt(node) ::= "<annotations(node)>skip;"

SuspendStmt(node) ::= "<annotations(node)>suspend;"

AssertStmt(node) ::= "<annotations(node)>assert <(node.condition.templateName)(node.condition)>;"

ThrowStmt(node) ::= "<annotations(node)>throw <(node.reason.templateName)(node.reason)>;"

DieStmt(node) ::= "<annotations(node)>die <(node.reason.templateName)(node.reason)>;"

ExpressionStmt(node) ::= "<annotations(node)><(node.exp.templateName)(node.exp)>;"

VarDeclStmt(node) ::= "<annotations(node)><(node.varDecl.templateName)(node.varDecl)>;"

AssignStmt(node) ::= "<annotations(node)><(node.var.templateName)(node.var)> = <(node.value.templateName)(node.value)>;"

ReturnStmt(node) ::= "<annotations(node)>return <(node.retExp.templateName)(node.retExp)>;"

DurationStmt(node) ::= "<annotations(node)>duration(<(node.min.templateName)(node.min)>, <(node.max.templateName)(node.max)>);"

AndGuard(node) ::= "<(node.left.templateName)(node.left)> & <(node.right.templateName)(node.right)>"

ClaimGuard(node) ::= "<(node.var.templateName)(node.var)>?"

DurationGuard(node) ::= "duration(<(node.min.templateName)(node.min)>, <(node.max.templateName)(node.max)>)"

ExpGuard(node) ::= "<(node.pureExp.templateName)(node.pureExp)>"

AwaitStmt(node) ::= "<annotations(node)>await <(node.guard.templateName)(node.guard)>;"

Block(node) ::= <<
<annotationsNL(node)>{
    <node.stmtList:{s | <(s.templateName)(s)>};separator="\n">
}
>>

MainBlock ::= Block

IfStmt(node) ::= "<annotations(node)>if (<(node.condition.templateName)(node.condition)>) <(node.thenCase.templateName)(node.thenCase)><if (node.elseCase)> else <(node.elseCase.templateName)(node.elseCase)><endif>"

WhileStmt(node) ::= "<annotations(node)>while (<(node.condition.templateName)(node.condition)>) <(node.body.templateName)(node.body)>"

ForeachStmt(node) ::= "<annotations(node)>foreach (<node.loopVarDecl.name> in <(node.listExp.templateName)(node.listExp)>) <(node.body.templateName)(node.body)>"

CaseStmt(node) ::= <<
<annotations(node)>case <(node.expr.templateName)(node.expr)> {
    <node.branchList:{b | <(b.left.templateName)(b.left)> => <(b.right.templateName)(b.right)>
}>
}
>>

TryCatchFinallyStmt(node) ::= <<
<annotations(node)>try <(node.body.templateName)(node.body)> catch {
    <node.catchs:{b | <(b.left.templateName)(b.left)> => <(b.right.templateName)(b.right)>
}>}<if (node.finally)> finally <(node.finally.templateName)(node.finally)><endif>
>>

// * Interfaces, Classes

ClassParamDecl ::= ParamDecl
InitBlock ::= Block

FieldDecl(node) ::= <<
<annotations(node)><(node.access.templateName)(node.access)> <node.name><if (node.initExp)> = <(node.initExp.templateName)(node.initExp)><endif>;
>>

MethodSig(node) ::= <<
<annotations(node)><(node.returnType.templateName)(node.returnType)> <node.name>(<node.params:{p | <(p.templateName)(p)>};separator=", ">)
>>

MethodImpl(node) ::= <<
<(node.methodSig.templateName)(node.methodSig)> <(node.block.templateName)(node.block)>
>>

InterfaceDecl(node) ::= <<
<annotationsNL(node)>interface <node.name> <\\>
<if (node.extendedInterfaceUse)>extends <node.extendedInterfaceUses:{e | <(e.templateName)(e)>};separator=", "> <endif><\\>
{
    <node.Bodys:{ms | <(ms.templateName)(ms)>;
}>}
>>

ClassDecl(node) ::= <<
<annotationsNL(node)>class <node.name> <\\>
<if (node.param)>(<node.params:{p | <(p.templateName)(p)>};separator=", ">) <endif><\\>
<if (node.implementedInterfaceUse)>implements <node.implementedInterfaceUses:{e | <(e.templateName)(e)>};separator=", "> <endif><\\>
{
    <node.fields:{f | <(f.templateName)(f)>
    }>
    <if (node.initBlock)>
    <(node.initBlock.templateName)(node.initBlock)>

    <endif>
    <if (node.recoverBranch)>
    recover {
        <node.recoverBranchs:{r | <(r.left.templateName)(r.left)> => <(r.right.templateName)(r.right)>};separator="\n">
    }

    <endif>
    <node.methods:{m | <(m.templateName)(m)>};separator="\n\n">
}
>>

// * Modules

Name(node) ::= "<node.name>"

NamedExport(node) ::= "export <node.names:{ex | <(ex.templateName)(ex)>};separator=\", \">;"

StarExport(node) ::= "export *<if (node.moduleName)> from <node.moduleName><endif>;"

FromExport(node) ::= "export <node.names:{ex | <(ex.templateName)(ex)>};separator=\", \"> from <node.moduleName>;"

NamedImport(node) ::= "import <node.names:{im | <(im.templateName)(im)>};separator=\", \">;"

StarImport(node) ::= "import * from <node.moduleName>;"

FromImport(node) ::= "import <node.names:{im | <(im.templateName)(im)>};separator=\", \"> from <node.moduleName>;"

