
// https://github.com/antlr/stringtemplate4/blob/master/doc/cheatsheet.md
// https://github.com/antlr/stringtemplate4/blob/master/doc/groups.md

// * Pure Expressions

IntLiteral(node) ::= "\"num\"[<node.content>] "
FloatLiteral(node) ::= "\"float\"[<node.content>] "
StringLiteral(node) ::= "\"str\"[\"<node.maudeEscapedString>\"] "
ListLiteral(node) ::= <<
<node.pureExps:{e | "ABS.StdLib.Cons"[<(e.templateName)(e)> :: }>"ABS.StdLib.Nil"[ emp ]<node.pureExps:{e | ]}> 
>>

ThisExp(node) ::= "'this "
NullExp(node) ::= "null "

VarUse(node) ::= "'<node.name> "
FieldUse(node) ::= "@ '<node.name> "

MinusExp(node) ::= "\"--\"(<(node.operand.templateName)(node.operand)>) "
NegExp(node) ::= "\"~\"(<(node.operand.templateName)(node.operand)>) "

EqExp(node) ::= "\"==\"(<(node.left.templateName)(node.left)>:: <(node.right.templateName)(node.right)>) "
NotEqExp(node) ::= "\"/=\"(<(node.left.templateName)(node.left)>:: <(node.right.templateName)(node.right)>) "
AndBoolExp(node) ::= "\"&&\"(<(node.left.templateName)(node.left)>:: <(node.right.templateName)(node.right)>) "
OrBoolExp(node) ::= "\"||\"(<(node.left.templateName)(node.left)>:: <(node.right.templateName)(node.right)>) "
LTExp(node) ::= "\"\<\"(<(node.left.templateName)(node.left)>:: <(node.right.templateName)(node.right)>) "
GTExp(node) ::= "\"\>\"(<(node.left.templateName)(node.left)>:: <(node.right.templateName)(node.right)>) "
LTEQExp(node) ::= "\"\<=\"(<(node.left.templateName)(node.left)>:: <(node.right.templateName)(node.right)>) "
GTEQExp(node) ::= "\"\>=\"(<(node.left.templateName)(node.left)>:: <(node.right.templateName)(node.right)>) "
AddAddExp(node) ::= "\"+\"(<(node.left.templateName)(node.left)>:: <(node.right.templateName)(node.right)>) "
SubAddExp(node) ::= "\"-\"(<(node.left.templateName)(node.left)>:: <(node.right.templateName)(node.right)>) "
MultMultExp(node) ::= "\"*\"(<(node.left.templateName)(node.left)>:: <(node.right.templateName)(node.right)>) "
DivMultExp(node) ::= "\"/\"(<(node.left.templateName)(node.left)>:: <(node.right.templateName)(node.right)>) "
ModMultExp(node) ::= "\"%\"(<(node.left.templateName)(node.left)>:: <(node.right.templateName)(node.right)>) "

DataConstructorExp(node) ::= <<
"<node.dataConstructor.qualifiedName>"[<if(node.param)>(<node.params:{a | <(a.templateName)(a)>}; separator=") :: (">) <else>emp <endif>]
>>

LetExp(node) ::= <<
( let '<node.var.name> = <(node.val.templateName)(node.val)>
  in
  <(node.exp.templateName)(node.exp)>)
>>

IfExp(node) ::= <<
if <(node.condExp.templateName)(node.condExp)>
th <(node.thenExp.templateName)(node.thenExp)>
el <(node.elseExp.templateName)(node.elseExp)>
fi 
>>


// TODO append extra "num"[0] for random() or rewrite random to not need it

// TODO handle isFunctionalBreakpoint() (??)
FnApp(node) ::= <<
"<node.decl.qualifiedName>"(<if(node.param)>(<node.params:{a | <(a.templateName)(a)>}; separator=") :: (">) <else>emp <endif>) 
>>

CaseExp(node) ::= <<
case <(node.expr.templateName)(node.expr)> of {
  <node.branchs:{b | <(b.left.templateName)(b.left)> => (<(b.right.templateName)(b.right)>)};separator=";\n">
}
>>

UnderscorePattern(node) ::= "'_ "
PatternVar(node) ::= "<(node.var.templateName)(node.var)>"
PatternVarUse(node) ::= "'<node.name> "
PatternVarDecl(node) ::= "'<node.name> "
LiteralPattern(node) ::= "<(node.literal.templateName)(node.literal)>"
ConstructorPattern(node) ::= <<
"<node.dataConstructor.qualifiedName>"[<if(node.param)>(<node.params:{a | <(a.templateName)(a)>}; separator=") :: (">) <else>emp <endif>]
>>

// * Statement Helpers
costannotation(node) ::= <<
<if(node.costAnnotation)>$cost(<(node.costAnnotation.templateName)(node.costAnnotation)>) ;
<endif>
>>

// * Statements

SkipStmt(node) ::= <<
<costannotation(node)>
skip 
>>

SuspendStmt(node) ::= <<
<costannotation(node)>
suspend 
>>

DurationStmt(node) ::= <<
<costannotation(node)>
duration(<(node.min.templateName)(node.min)> ; <(node.max.templateName)(node.max)>) 
>>

MoveCogToStmt(node) ::= <<
<costannotation(node)>
movecogto(<(node.target.templateName)(node.target)>)
>>

AssertStmt(node) ::= <<
<costannotation(node)>
assert <(node.condition.templateName)(node.condition)>
>>

ThrowStmt(node) ::= <<
<costannotation(node)>
throw (<(node.reason.templateName)(node.reason)>)
>>

DieStmt(node) ::= <<
<costannotation(node)>
die (<(node.reason.templateName)(node.reason)>)
>>

// Local Variables:
// comment-start: "// "
// End:
